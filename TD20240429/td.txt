#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

typedef enum
{
	POINT2D = 1,
	COLOR
} data_type;

typedef struct
{
	double x; /**< horizontal */
	double y; /**< vertical */
} point2D;

/**
 *
 */
typedef struct
{
	uint8_t r;
	uint8_t g;
	uint8_t b;
} color;

typedef struct
{
	data_type type;
	size_t qty;
	uint8_t checksum;
} header;

typedef union
{
	point2D p;
	color c;
} data;

typedef struct
{
	header h;
	data *d;
} packet;

void display_packet(const packet p)
{
	size_t index = 0;
	for (index = 0; index < p.h.qty; index++)
	{
		switch (p.h.type)
		{
		case POINT2D:
			printf("Point2D: x=%+6.3lf, y=%+6.3lf\n",
				   p.d[index].p.x, p.d[index].p.y);
			break;
		case COLOR:
			printf("Color: r=%3d, g=%3d, b=%3d\n",
				   p.d[index].c.r, p.d[index].c.g, p.d[index].c.b);
			break;
		default:
			puts("Unknown packet type.");
			break;
		}
	}
}

void send(const packet p, char *buff)
{
	size_t n = sizeof(header) + p.h.qty * sizeof(data);
	memcpy(buff, &(p.h), sizeof(header));
	buff += sizeof(header);
	memcpy( buff, p.d, p.h.qty * sizeof(data));

}

void receive(char *buff, packet *p)
{
	packet *tmp = (packet *)buff;
	size_t n = sizeof(header) + tmp->h.qty * sizeof(data);
	memcpy(&(p->h), buff, sizeof(header));
	buff += sizeof(header);
	data *pdata = (data *)malloc(p->h.qty * sizeof(data));
	p->d = pdata;
	memcpy(p->d, buff, p->h.qty * sizeof(data));
}

int main(void)
{
	packet p1;
	packet p2;
	char *buffer = NULL;
	p1.h.type = POINT2D;
	p1.h.qty = 5;
	p1.h.checksum = 0x00;

	data *pdata = (data *)malloc(p1.h.qty * sizeof(data));
	p1.d = pdata;
	p1.d[0].p.x = 10.;
	p1.d[0].p.y = 15.;
	p1.d[1].p.x = 20.;
	p1.d[1].p.y = 25.;
	p1.d[2].p.x = 30.;
	p1.d[2].p.y = 35.;
	p1.d[3].p.x = 40.;
	p1.d[3].p.y = 45.;
	p1.d[4].p.x = 50.;
	p1.d[4].p.y = 55.;

	size_t n = sizeof(header) + p1.h.qty * sizeof(data);
	printf("main: n=%ld\n", n);

	buffer = (char *)malloc(n);
	if (NULL == buffer)
	{
		printf("Error, unable to allocate memory for the buffer.");
		return 1;
	}

	display_packet(p1);
	send(p1, buffer);
	receive(buffer, &p2);
	display_packet(p2);

	return 0;
}

/*
typedef struct {
	double r;
	double i;
} complex;

complex c1= {.r=0., .i=4.};

struct complex {
	double r;
	double i;
};

struct complex c1;

typedef struct complex {
	double r;
	double i;
} complex;

complex c1;
*/